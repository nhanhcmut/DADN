const mqtt = require('mqtt');
const Device = require('../models/Device');
const SensorData = require('../models/SensorData');
const WaterProcess = require('../models/WaterProcess');
const ActivationCondition = require('../models/ActivationCondition');

class MqttService {
    constructor() {
        this.clients = {}; // Ch·ª©a c√°c k·∫øt n·ªëi MQTT cho t·ª´ng thi·∫øt b·ªã
        this.connectAllDevices(); // K·∫øt n·ªëi t·∫•t c·∫£ thi·∫øt b·ªã khi kh·ªüi t·∫°o d·ªãch v·ª•
    }

    // H√†m l·∫•y t·∫•t c·∫£ thi·∫øt b·ªã t·ª´ MongoDB
    async getAllDevices() {
        try {
            const devices = await Device.find({});
            console.log('Danh s√°ch thi·∫øt b·ªã t·ª´ MongoDB:', devices);
            return devices;
        } catch (error) {
            console.error('L·ªói khi l·∫•y danh s√°ch thi·∫øt b·ªã:', error);
            throw error;
        }
    }

    // H√†m k·∫øt n·ªëi t·∫•t c·∫£ thi·∫øt b·ªã l√™n MQTT
    async connectAllDevices() {
        try {
            const devices = await this.getAllDevices();
            devices.forEach(device => {
                if (device.usernameaio && device.keyaio) {
                    this.connect(device);
                } else {
                    console.warn(`Thi·∫øt b·ªã ${device.name} thi·∫øu th√¥ng tin ƒëƒÉng nh·∫≠p MQTT`);
                }
            });
        } catch (error) {
            console.error('L·ªói khi k·∫øt n·ªëi t·∫•t c·∫£ thi·∫øt b·ªã:', error);
        }
    }

    // H√†m k·∫øt n·ªëi m·ªôt thi·∫øt b·ªã ƒë·∫øn broker MQTT
    connect(device) {
        const brokerUrl = 'mqtt://io.adafruit.com';

        if (!device || !device._id || !device.name) {
            console.error('L·ªói: Device b·ªã undefined ho·∫∑c thi·∫øu thu·ªôc t√≠nh quan tr·ªçng!');
            return;
        }

        // N·∫øu thi·∫øt b·ªã ƒë√£ k·∫øt n·ªëi r·ªìi, ng·∫Øt k·∫øt n·ªëi c≈©
        if (this.clients[device._id]) {
            this.clients[device._id].end(true);
        }

        console.log(`K·∫øt n·ªëi MQTT cho thi·∫øt b·ªã: ${device.name}`);

        // K·∫øt n·ªëi v·ªõi Adafruit
        const client = mqtt.connect(brokerUrl, {
            username: device.usernameaio,
            password: device.keyaio,
            reconnectPeriod: 5000,
            connectTimeout: 30000
        });

        client.on('connect', async () => {
            console.log(`üì° Thi·∫øt b·ªã ${device.name} ƒë√£ k·∫øt n·ªëi MQTT`);
            this.subscribeToFeeds(client, device);

            // G·ª≠i to√†n b·ªô d·ªØ li·ªáu l√™n Adafruit sau khi k·∫øt n·ªëi th√†nh c√¥ng
            await this.sendDeviceDataToAdafruit(client, device);
        });

        client.on('error', (error) => {
            console.error(`L·ªói k·∫øt n·ªëi MQTT cho thi·∫øt b·ªã ${device.name}:`, error);
        });

        client.on('message', async (topic, message) => {
            await this.handleMessage(device, topic, message);
        });

        this.clients[device._id] = client;
    }

    // H√†m g·ª≠i d·ªØ li·ªáu thi·∫øt b·ªã l√™n Adafruit
    async sendDeviceDataToAdafruit(client, device) {
        try {
            const sensorData = await SensorData.findOne({ deviceId: device._id });
            const waterProcess = await WaterProcess.findOne({ deviceId: device._id });
            const activationCondition = await ActivationCondition.findOne({ deviceId: device._id });

            if (sensorData || waterProcess || activationCondition) {
                console.log(`üöÄ ƒêang g·ª≠i to√†n b·ªô d·ªØ li·ªáu l√™n Adafruit...`);

                const feedMapping = {
                    'temp': sensorData?.tempvalue,
                    'humid': sensorData?.humidvalue,
                    'tempswitch': waterProcess?.tempControlled,
                    'humidswitch': waterProcess?.humidControlled,
                    'pump': waterProcess?.manualControl,
                    'speed': waterProcess?.pumpSpeed,
                    'tempstart': activationCondition?.conditions.temperature.start,
                    'tempstop': activationCondition?.conditions.temperature.stop,
                    'humidstart': activationCondition?.conditions.humidity.start,
                    'humidstop': activationCondition?.conditions.humidity.stop
                };

                for (const [feed, value] of Object.entries(feedMapping)) {
                    if (value !== undefined && value !== null) {
                        await this.publishToDeviceFeed(device._id, feed, value.toString());
                        console.log(`‚úÖ ƒê√£ g·ª≠i d·ªØ li·ªáu l√™n ${feed}: ${value}`);
                    }
                }
            }
        } catch (error) {
            console.error("üö® L·ªói khi g·ª≠i to√†n b·ªô d·ªØ li·ªáu l√™n Adafruit:", error);
        }
    }

    // H√†m ƒëƒÉng k√Ω nh·∫≠n d·ªØ li·ªáu t·ª´ c√°c feed c·ªßa thi·∫øt b·ªã
    subscribeToFeeds(client, device) {
        const feeds = [
            'temp', 'humid', 'tempswitch', 'humidswitch', 
            'pump', 'speed', 'tempstart', 'tempstop', 
            'humidstart', 'humidstop'
        ];

        feeds.forEach(feed => {
            const topic = `${device.usernameaio}/feeds/${feed}`;
            client.subscribe(topic, (err) => {
                if (err) {
                    console.error(`L·ªói khi ƒëƒÉng k√Ω ${feed}:`, err);
                } else {
                    console.log(`ƒê√£ ƒëƒÉng k√Ω nh·∫≠n d·ªØ li·ªáu t·ª´ ${topic}`);
                }
            });
        });
    }

    // H√†m g·ª≠i d·ªØ li·ªáu l√™n Adafruit
    async publishToDeviceFeed(deviceId, feed, value) {
        try {
            const device = await Device.findById(deviceId);
            if (!device) {
                throw new Error('Thi·∫øt b·ªã kh√¥ng t·ªìn t·∫°i');
            }
    
            const client = this.clients[deviceId];
            if (!client) {
                throw new Error(`Thi·∫øt b·ªã ${device.name} ch∆∞a k·∫øt n·ªëi MQTT`);
            }
    
            const topic = `${device.usernameaio}/feeds/${feed}`;
    
            // N·∫øu feed thu·ªôc nh√≥m ki·ªÉm so√°t, chuy·ªÉn ƒë·ªïi gi√° tr·ªã th√†nh chu·ªói "ON"/"OFF"
            const controlFeeds = ["tempControlled", "humidControlled", "manualControl"];
            if (controlFeeds.includes(feed)) {
                value = value === "true" ? "1" : "0";
            }
    
            client.publish(topic, value.toString());
            console.log(`üì§ G·ª≠i d·ªØ li·ªáu ƒë·∫øn ${topic}: ${value}`);
        } catch (error) {
            console.error("üö® L·ªói khi g·ª≠i d·ªØ li·ªáu:", error);
        }
    }
    

    // H√†m x·ª≠ l√Ω c√°c message t·ª´ Adafruit
    async handleMessage(device, topic, message) {
        try {
            if (!device) {
                console.error("L·ªói: Device b·ªã undefined!");
                return;
            }

            const value = message.toString();
            const feedType = this.getFeedTypeFromTopic(topic);

            let sensorData = await SensorData.findOne({ deviceId: device._id });

            if (!sensorData) {
                sensorData = new SensorData({
                    deviceId: device._id,
                    humidvalue: feedType === "humidity" ? value : "0",
                    tempvalue: feedType === "temperature" ? value : "0",
                    timestamp: new Date()
                });
            } else {
                if (feedType === "temperature") {
                    sensorData.tempvalue = value;
                } else if (feedType === "humidity") {
                    sensorData.humidvalue = value;
                }
                sensorData.timestamp = new Date();
            }

            await sensorData.save();
            console.log("üì° D·ªØ li·ªáu nhi·ªát ƒë·ªô & ƒë·ªô ·∫©m ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t:", sensorData);

            // C·∫≠p nh·∫≠t WaterProcess n·∫øu c√≥
            if (['tempControlled', 'humidControlled', 'manualControl', 'pumpSpeed'].includes(feedType)) {
                let waterProcess = await WaterProcess.findOneAndUpdate(
                    { deviceId: device._id },
                    { $set: { updatedAt: new Date() }, $setOnInsert: { startTime: new Date(), status: "SCHEDULED" } },
                    { upsert: true, new: true }
                );

                if (feedType === 'pumpSpeed') {
                    waterProcess.pumpSpeed = parseInt(value);
                } else {
                    waterProcess[feedType] = value === '1';
                }

                await waterProcess.save();
                console.log(`üíß ƒê√£ c·∫≠p nh·∫≠t WaterProcess cho thi·∫øt b·ªã ${device._id}:`, waterProcess);
            }

            // C·∫≠p nh·∫≠t ActivationCondition n·∫øu c√≥
            if (['tempStart', 'tempStop', 'humidStart', 'humidStop'].includes(feedType)) {
                let condition = await ActivationCondition.findOneAndUpdate(
                    { deviceId: device._id },
                    { $set: { updatedAt: new Date() }, $setOnInsert: { description: "connect to adafruit", flag: true } },
                    { upsert: true, new: true }
                );

                if (feedType === 'tempStart') {
                    condition.conditions.temperature.start = value;
                } else if (feedType === 'tempStop') {
                    condition.conditions.temperature.stop = value;
                } else if (feedType === 'humidStart') {
                    condition.conditions.humidity.start = value;
                } else if (feedType === 'humidStop') {
                    condition.conditions.humidity.stop = value;
                }

                await condition.save();
                console.log(`üî• ƒê√£ c·∫≠p nh·∫≠t ActivationCondition cho thi·∫øt b·ªã ${device._id}:`, condition);
            }
        } catch (error) {
            console.error("üö® L·ªói x·ª≠ l√Ω MQTT message:", error);
        }
    }

    // H√†m x√°c ƒë·ªãnh lo·∫°i feed t·ª´ topic
    getFeedTypeFromTopic(topic) {
        const feed = topic.split('/').pop();
        const feedMap = {
            'temp': 'temperature',
            'humid': 'humidity',
            'tempswitch': 'tempControlled',
            'humidswitch': 'humidControlled', 
            'pump': 'manualControl',
            'speed': 'pumpSpeed',
            'tempstart': 'tempStart',
            'tempstop': 'tempStop',
            'humidstart': 'humidStart',
            'humidstop': 'humidStop'
        };
        return feedMap[feed] || feed;
    }

    // Ng·∫Øt k·∫øt n·ªëi MQTT khi c·∫ßn
    disconnect() {
        Object.values(this.clients).forEach(client => client.end());
        console.log('Disconnected from MQTT broker');
    }
}

module.exports = new MqttService();
